{"version":3,"sources":["App.jsx","index.js"],"names":["sdk","ThirdwebSDK","bundleDropModule","getBundleDropModule","tokenModule","getTokenModule","voteModule","getVoteModule","App","useWeb3","connectWallet","address","error","provider","console","log","useState","memberTokenAmounts","setMemberTokenAmounts","memberAddresses","setMemberAddresses","signer","getSigner","undefined","hasClaimedNFT","setHasClaimedNFT","isClaiming","setIsClaiming","proposals","setProposals","isVoting","setIsVoting","hasVoted","setHasVoted","useEffect","getAll","then","catch","err","length","proposalId","setProviderOrSigner","balanceOf","balance","gt","getAllClaimerAddresses","addresess","getAllHolderBalances","amounts","memberList","useMemo","map","tokenAmount","ethers","utils","formatUnits","UnsupportedChainIdError","className","onClick","member","str","substring","onSubmit","e","a","preventDefault","stopPropagation","votes","proposal","voteResult","vote","forEach","document","getElementById","type","checked","getDelegationOf","constants","AddressZero","delegateTo","Promise","all","get","state","execute","index","description","id","name","value","defaultChecked","htmlFor","label","disabled","claim","finally","ReactDOM","render","StrictMode","connectors","injected","supportedChainIds"],"mappings":"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","file":"static/js/main.b381b2eb.chunk.js","sourcesContent":["import { useEffect, useMemo, useState } from \"react\";\nimport { ThirdwebSDK } from \"@3rdweb/sdk\";\nimport { ethers } from \"ethers\";\nimport { UnsupportedChainIdError } from \"@web3-react/core\";\n\n// import thirdweb\nimport { useWeb3 } from \"@3rdweb/hooks\";\n\n// We instantiate the sdk on Rinkeby.\nconst sdk = new ThirdwebSDK(\"rinkeby\");\n\n// We can grab a reference to our ERC-1155 contract.\nconst bundleDropModule = sdk.getBundleDropModule(\n  \"0x7B4E4E8105A719a1c67A00f082Ef2D1D0Ef27a7c\",\n);\n\nconst tokenModule = sdk.getTokenModule(\n  \"0x4aB847CcdA81A7Ec3B7Fe9edca9D998Efba542f4\"\n);\n\nconst voteModule = sdk.getVoteModule(\n  \"0xA868b7985a1f5389D0a47063490402965126aEc6\",\n);\n\n\nconst App = () => {\n  // Use the connectWallet hook thirdweb gives us.\n  const { connectWallet, address, error, provider } = useWeb3();\n  console.log(\"👋 Address:\", address)\n\n  // Holds the amount of token each member has in state.\n  const [memberTokenAmounts, setMemberTokenAmounts] = useState({});\n  // The array holding all of our members addresses.\n  const [memberAddresses, setMemberAddresses] = useState([]);\n\n  // A fancy function to shorten someones wallet address, no need to show the whole thing. \n  const shortenAddress = (str) => {\n    return str.substring(0, 6) + \"...\" + str.substring(str.length - 4);\n  };\n\n  // The signer is required to sign transactions on the blockchain.\n  // Without it we can only read data, not write.\n  const signer = provider ? provider.getSigner() : undefined;\n\n  const [hasClaimedNFT, setHasClaimedNFT] = useState(false);\n  // isClaiming lets us easily keep a loading state while the NFT is minting.\n  const [isClaiming, setIsClaiming] = useState(false);\n  \n  const [proposals, setProposals] = useState([]);\n  const [isVoting, setIsVoting] = useState(false);\n  const [hasVoted, setHasVoted] = useState(false);\n  \n  // Retrieve all our existing proposals from the contract.\n  useEffect(() => {\n    if (!hasClaimedNFT) {\n      return;\n    }\n    // A simple call to voteModule.getAll() to grab the proposals.\n    voteModule\n      .getAll()\n      .then((proposals) => {\n        // Set state!\n        setProposals(proposals);\n        console.log(\"🌈 Proposals:\", proposals)\n      })\n      .catch((err) => {\n        console.error(\"failed to get proposals\", err);\n      });\n  }, [hasClaimedNFT]);\n\n  // We also need to check if the user already voted.\n  useEffect(() => {\n    if (!hasClaimedNFT) {\n      return;\n    }\n\n    // If we haven't finished retrieving the proposals from the useEffect above\n    // then we can't check if the user voted yet!\n    if (!proposals.length) {\n      return;\n    }\n\n    // Check if the user has already voted on the first proposal.\n    voteModule\n      .hasVoted(proposals[0].proposalId, address)\n      .then((hasVoted) => {\n        setHasVoted(hasVoted);\n        if (hasVoted) {\n          console.log(\"🥵 User has already voted\")\n        }\n      })\n      .catch((err) => {\n        console.error(\"failed to check if wallet has voted\", err);\n      });\n  }, [hasClaimedNFT, proposals, address]);\n\n  // Another useEffect!\n  useEffect(() => {\n    // We pass the signer to the sdk, which enables us to interact with\n    // our deployed contract!\n    sdk.setProviderOrSigner(signer);\n  }, [signer]);\n\n  useEffect(() => {\n    // If they don't have an connected wallet, exit!\n    if (!address) {\n      return;\n    }\n\n    // Check if the user has the NFT by using bundleDropModule.balanceOf\n    return bundleDropModule\n      .balanceOf(address, \"0\")\n      .then((balance) => {\n        // If balance is greater than 0, they have our NFT!\n        if (balance.gt(0)) {\n          setHasClaimedNFT(true);\n          console.log(\"🌟 this user has a membership NFT!\")\n        } else {\n          setHasClaimedNFT(false);\n          console.log(\"😭 this user doesn't have a membership NFT.\")\n        }\n      })\n      .catch((error) => {\n        setHasClaimedNFT(false);\n        console.error(\"failed to nft balance\", error);\n      });\n  }, [address]);\n\n\n  // This useEffect grabs all the addresses of our members holding our NFT.\n  useEffect(() => {\n    if (!hasClaimedNFT) {\n      return;\n    }\n    \n    // Just like we did in the 7-airdrop-token.js file! Grab the users who hold our NFT\n    // with tokenId 0.\n    bundleDropModule\n      .getAllClaimerAddresses(\"0\")\n      .then((addresess) => {\n        console.log(\"🚀 Members addresses\", addresess)\n        setMemberAddresses(addresess);\n      })\n      .catch((err) => {\n        console.error(\"failed to get member list\", err);\n      });\n  }, [hasClaimedNFT]);\n\n  // This useEffect grabs the # of token each member holds.\n  useEffect(() => {\n    if (!hasClaimedNFT) {\n      return;\n    }\n\n    // Grab all the balances.\n    tokenModule\n      .getAllHolderBalances()\n      .then((amounts) => {\n        console.log(\"👜 Amounts\", amounts)\n        setMemberTokenAmounts(amounts);\n      })\n      .catch((err) => {\n        console.error(\"failed to get token amounts\", err);\n      });\n  }, [hasClaimedNFT]);\n\n\n  // Now, we combine the memberAddresses and memberTokenAmounts into a single array\n  const memberList = useMemo(() => {\n    return memberAddresses.map((address) => {\n      return {\n        address,\n        tokenAmount: ethers.utils.formatUnits(\n          // If the address isn't in memberTokenAmounts, it means they don't\n          // hold any of our token.\n          memberTokenAmounts[address] || 0,\n          18,\n        ),\n      };\n    });\n  }, [memberAddresses, memberTokenAmounts]);\n\n  if (error instanceof UnsupportedChainIdError ) {\n    return (\n      <div className=\"unsupported-network\">\n        <h2>Please connect to Rinkeby</h2>\n        <p>\n          This dapp only works on the Rinkeby network, please switch networks\n          in your connected wallet.\n        </p>\n      </div>\n    );\n  }\n\n  // This is the case where the user hasn't connected their wallet\n  // to your web app. Let them call connectWallet.\n  if (!address) {\n    return (\n      <div className=\"landing\">\n        <h1>Welcome to DaoYiYouDao</h1>\n        <button onClick={() => connectWallet(\"injected\")} className=\"btn-hero\">\n          Connect your wallet\n        </button>\n      </div>\n    );\n  }\n\n    // If the user has already claimed their NFT we want to display the interal DAO page to them\n    // only DAO members will see this. Render all the members + token amounts.\n    if (hasClaimedNFT) {\n      return (\n        <div className=\"member-page\">\n          <h1>🍪DAO Member Page</h1>\n          <p>Congratulations on being a member</p>\n          <div>\n            <div>\n              <h2>Member List</h2>\n              <table className=\"card\">\n                <thead>\n                  <tr>\n                    <th>Address</th>\n                    <th>Token Amount</th>\n                  </tr>\n                </thead>\n                <tbody>\n                  {memberList.map((member) => {\n                    return (\n                      <tr key={member.address}>\n                        <td>{shortenAddress(member.address)}</td>\n                        <td>{member.tokenAmount}</td>\n                      </tr>\n                    );\n                  })}\n                </tbody>\n              </table>\n            </div>\n            <div>\n              <h2>Active Proposals</h2>\n              <form\n                onSubmit={async (e) => {\n                  e.preventDefault();\n                  e.stopPropagation();\n  \n                  //before we do async things, we want to disable the button to prevent double clicks\n                  setIsVoting(true);\n  \n                  // lets get the votes from the form for the values\n                  const votes = proposals.map((proposal) => {\n                    let voteResult = {\n                      proposalId: proposal.proposalId,\n                      //abstain by default\n                      vote: 2,\n                    };\n                    proposal.votes.forEach((vote) => {\n                      const elem = document.getElementById(\n                        proposal.proposalId + \"-\" + vote.type\n                      );\n  \n                      if (elem.checked) {\n                        voteResult.vote = vote.type;\n                        return;\n                      }\n                    });\n                    return voteResult;\n                  });\n  \n                  // first we need to make sure the user delegates their token to vote\n                  try {\n                    //we'll check if the wallet still needs to delegate their tokens before they can vote\n                    const delegation = await tokenModule.getDelegationOf(address);\n                    // if the delegation is the 0x0 address that means they have not delegated their governance tokens yet\n                    if (delegation === ethers.constants.AddressZero) {\n                      //if they haven't delegated their tokens yet, we'll have them delegate them before voting\n                      await tokenModule.delegateTo(address);\n                    }\n                    // then we need to vote on the proposals\n                    try {\n                      await Promise.all(\n                        votes.map(async (vote) => {\n                          // before voting we first need to check whether the proposal is open for voting\n                          // we first need to get the latest state of the proposal\n                          const proposal = await voteModule.get(vote.proposalId);\n                          // then we check if the proposal is open for voting (state === 1 means it is open)\n                          if (proposal.state === 1) {\n                            // if it is open for voting, we'll vote on it\n                            return voteModule.vote(vote.proposalId, vote.vote);\n                          }\n                          // if the proposal is not open for voting we just return nothing, letting us continue\n                          return;\n                        })\n                      );\n                      try {\n                        // if any of the propsals are ready to be executed we'll need to execute them\n                        // a proposal is ready to be executed if it is in state 4\n                        await Promise.all(\n                          votes.map(async (vote) => {\n                            // we'll first get the latest state of the proposal again, since we may have just voted before\n                            const proposal = await voteModule.get(\n                              vote.proposalId\n                            );\n  \n                            //if the state is in state 4 (meaning that it is ready to be executed), we'll execute the proposal\n                            if (proposal.state === 4) {\n                              return voteModule.execute(vote.proposalId);\n                            }\n                          })\n                        );\n                        // if we get here that means we successfully voted, so let's set the \"hasVoted\" state to true\n                        setHasVoted(true);\n                        // and log out a success message\n                        console.log(\"successfully voted\");\n                      } catch (err) {\n                        console.error(\"failed to execute votes\", err);\n                      }\n                    } catch (err) {\n                      console.error(\"failed to vote\", err);\n                    }\n                  } catch (err) {\n                    console.error(\"failed to delegate tokens\");\n                  } finally {\n                    // in *either* case we need to set the isVoting state to false to enable the button again\n                    setIsVoting(false);\n                  }\n                }}\n              >\n                {proposals.map((proposal, index) => (\n                  <div key={proposal.proposalId} className=\"card\">\n                    <h5>{proposal.description}</h5>\n                    <div>\n                      {proposal.votes.map((vote) => (\n                        <div key={vote.type}>\n                          <input\n                            type=\"radio\"\n                            id={proposal.proposalId + \"-\" + vote.type}\n                            name={proposal.proposalId}\n                            value={vote.type}\n                            //default the \"abstain\" vote to chedked\n                            defaultChecked={vote.type === 2}\n                          />\n                          <label htmlFor={proposal.proposalId + \"-\" + vote.type}>\n                            {vote.label}\n                          </label>\n                        </div>\n                      ))}\n                    </div>\n                  </div>\n                ))}\n                <button disabled={isVoting || hasVoted} type=\"submit\">\n                  {isVoting\n                    ? \"Voting...\"\n                    : hasVoted\n                      ? \"You Already Voted\"\n                      : \"Submit Votes\"}\n                </button>\n                <small>\n                  This will trigger multiple transactions that you will need to\n                  sign.\n                </small>\n              </form>\n            </div>\n          </div>\n        </div>\n      );\n    };\n\n  const mintNft = () => {\n    setIsClaiming(true);\n    // Call bundleDropModule.claim(\"0\", 1) to mint nft to user's wallet.\n    bundleDropModule\n    .claim(\"0\", 1)\n    .then(() => {\n      // Set claim state.\n      setHasClaimedNFT(true);\n      // Show user their fancy new NFT!\n      console.log(\n        `🌊 Successfully Minted! Check it out on OpenSea: https://testnets.opensea.io/assets/${bundleDropModule.address}/0`\n      );\n    })\n    .catch((err) => {\n      console.error(\"failed to claim\", err);\n    })\n    .finally(() => {\n      // Stop loading state.\n      setIsClaiming(false);\n    });\n  }\n  \n  // Render mint nft screen.\n  return (\n    <div className=\"mint-nft\">\n      <h1>Mint your free 🍪DAO Membership NFT</h1>\n      <button\n        disabled={isClaiming}\n        onClick={() => mintNft()}\n      >\n        {isClaiming ? \"Minting...\" : \"Mint your nft (FREE)\"}\n      </button>\n    </div>\n  );\n};\n\nexport default App;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\n// Import ThirdWeb\nimport { ThirdwebWeb3Provider } from '@3rdweb/hooks';\n\n// Include what chains you wanna support.\n// 4 = Rinkeby.\nconst supportedChainIds = [4];\n\n// Include what type of wallet you want to support.\n// In this case, we support Metamask which is an \"injected wallet\".\nconst connectors = {\n  injected: {},\n};\n\n// Finally, wrap App with ThirdwebWeb3Provider.\nReactDOM.render(\n  <React.StrictMode>\n    <ThirdwebWeb3Provider\n      connectors={connectors}\n      supportedChainIds={supportedChainIds}\n    >\n      <App />\n    </ThirdwebWeb3Provider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);"],"sourceRoot":""}